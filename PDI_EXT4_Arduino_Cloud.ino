#include "arduino_secrets.h"
///
/// @file PDI_EXT4_Arduino_Cloud.ino
/// @brief Home automation device with WiFi connectivity to Arduino cloud and dashboard for Pervasive Displays EXT4 extension board
///
/// @details Tested with Arduino Nano ESP32 boards and Arduino core
///
/// @author Rei Vilo
/// @date 27 Jan 2025
/// @version 810
///
/// @copyright (c) Rei Vilo, 2010-2025
/// * 2024-06-06 Rei Vilo (Pervasive Displays)
/// * Added support for EXT4
/// @copyright Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)
/// @copyright For exclusive use with Pervasive Displays screens
///
/// @see ReadMe.md
/// * HDC2080 2% RH ultra-low-power digital relative humidity sensor, interrupt/DRDY
/// https://www.ti.com/product/HDC2080
/// * Weather Sensors Library
/// https://github.com/rei-vilo/SensorsWeather_Library
/// * Arduino cloud and dashboard
/// https://cloud.arduino.cc/
/// * ESP32 core 3.0.7
/// https://github.com/espressif/arduino-esp32
///

///
/// The sketch was partially generated by the Arduino IoT Cloud Thing.
///
///   Arduino IoT Cloud Variables are
///
///     Type | Variable | Widget | READ/WRITE
///     ---- | ---- | ---- | ----
///     String | vText | Messenger | READ/WRITE
///     float | vHumidity | Value, float | READ
///     float | vTemperature | Value, float | READ
///     CloudColoredLight | vColour | Coloured light | READ/WRITE
///     bool | vStop | Button | READ/WRITE
///
/// > Variables which are marked as READ/WRITE in the Cloud Thing will also have functions which are called when their values are changed from the Dashboard.
/// > These functions are generated with the Thing and added at the end of this sketch.
///
/// The file `thingProperties.h` was partially generated by the Arduino IoT Cloud but contained a secret variable in plain text.
///
/// @code
/// --- Edited
/// const char DEVICE_LOGIN_NAME[] = SECRET_DEVICE_LOGIN_NAME; // Device login name
/// --- End of Edited
/// @endcode
///
/// `SECRET_DEVICE_LOGIN_NAME` has been added to `arduino_secrets.h`.
///
#include "Arduino.h"

// Define parameters
#define DELAY_MS 10000  // 10 s
#define LINES_NUMBER 4

//
// --- IoT
//
#include "arduino_secrets.h"

#include "thingProperties.h"

volatile bool flagRGB = false;
volatile bool flagText = false;
volatile bool flagStop = false;

void configureIoT()
{
    // Defined in thingProperties.h
    initProperties();

    // Connect to Arduino IoT Cloud
    ArduinoCloud.begin(ArduinoIoTPreferredConnection);

    /*
           The following function allows you to obtain more information
           related to the state of network and IoT Cloud connection and errors
           the higher number the more granular information you’ll get.
           The default is 0 (only errors).
           Maximum is 4
        */
    setDebugMessageLevel(2);
    ArduinoCloud.printDebugInfo();
}

void manageIoT()
{
}
//
// --- End of IoT
//

//
// --- Text
//
String lines[LINES_NUMBER];
uint8_t maxLines = LINES_NUMBER;
uint8_t indexLines = 0;

void configureText()
{
    for (uint8_t i = 0; i < LINES_NUMBER; i += 1)
    {
        lines[i] = "";
    }
}

void manageText()
{
    if (indexLines + 1 <= maxLines)
    {
        lines[indexLines] = vText;
        indexLines += 1;
    }
    else
    {
        for (uint8_t i = 1; i < maxLines; i += 1)
        {
            lines[i - 1] = lines[i];
        }
        lines[maxLines - 1] = vText;
    }
}
//
// --- End of text
//

//
// --- PDLS 8.x
//
#include "PDLS_EXT4_Basic_Matter.h"

#if (PDLS_EXT4_BASIC_MATTER_RELEASE < 810)
#error Required PDLS_EXT4_BASIC_MATTER_RELEASE 810
#endif  // PDLS_EXT4_BASIC_MATTER_RELEASE

// SDK and configuration
#include "hV_Common.h"

#if (USE_EXT_BOARD != BOARD_EXT4)
#error Required USE_EXT_BOARD = BOARD_EXT4
#endif  // USE_EXT_BOARD

#ifndef BOARD_USES_HW_GPIO_NUMBERS
#error Select Pin Numbering > By GPIO number (Legacy)
#endif  // BOARD_USES_HW_GPIO_NUMBERS

// Board definition for Arduino Nano ESP32 with Pin Numbering > By GPIO number (Legacy)
const pins_t myBoard =
{
    .panelBusy = D10,  ///< EXT3 and EXT3-1 pin 3 Red -> D10
    .panelDC = D9,     ///< EXT3 and EXT3-1 pin 4 Orange -> D9
    .panelReset = D8,  ///< EXT3 and EXT3-1 pin 5 Yellow -> D8
    .flashCS = D7,     ///< EXT3 and EXT3-1 pin 8 Violet -> D7
    .panelCS = D6,     ///< EXT3 and EXT3-1 pin 9 Grey -> D6

    .panelCSS = NOT_CONNECTED,    ///< EXT4 not available
    .flashCSS = D5,               ///< EXT3 pin 20 or EXT3-1 pin 11 Black2 -> D5
    .touchInt = NOT_CONNECTED,    ///< EXT3-Touch pin 3 Red
    .touchReset = NOT_CONNECTED,  ///< EXT3-Touch pin 4 Orange
    .panelPower = D2,             ///< EXT4 pin 20 White -> D2
    .cardCS = NOT_CONNECTED,      ///< Separate SD-card board
    .cardDetect = NOT_CONNECTED,  ///< Separate SD-card board

    // EXT4 specific
    .button = D3,   // EXT4 pin 12 Grey -> D3
    .ledData = D4,  // EXT4 pin 13 Violet WS2813C -> D4
    // ///< EXT4 pin 14 Blue -> I2C SDA
    // ///< EXT4 pin 15 Green -> I2C SCL
    // ///< EXT4 pin 16 Yellow, see above
    .nfcFD = A3,       // EXT4 pin 17 Orange NFC NT3H2111_2211 !Field detect, I2C address = 0x55 -> A3
    .imuInt1 = A2,     // EXT4 pin 18 Red LIS2DH12 !INT1, I2C address = 0x19 -> A2
    .imuInt2 = A1,     // EXT4 pin 19 Brown LIS2DH12 !INT2, I2C address = 0x19 -> A1
    .weatherInt = A0,  // EXT4 pin 20 Black HDC2080 !INT, I2C address = 0x40 -> A0
    // End of EXT4 specific
};

Screen_EPD_EXT4_Fast myScreen(eScreen_EPD_290_KS_0F, myBoard);
// Screen_EPD_EXT4_Fast myScreen(eScreen_EPD_266_KS_0C, myBoard);

uint16_t x, y, dx, dy;
uint16_t yLine, yText;  // The SDK declares y0 somewhere as double!

uint8_t fontMeasures = Font_Terminal16x24;
uint8_t fontText = Font_Terminal12x16;  // gTextLarge

static uint8_t countFlush = 1;         // Counter for global update
const uint8_t FAST_BEFORE_GLOBAL = 8;  // Number of fast updates before golbal update
bool flagDisplay = true;

void configureScreen()
{
    myScreen.begin();
    myScreen.regenerate();  // Clear buffer and screen

    myScreen.setOrientation(ORIENTATION_LANDSCAPE);

    x = myScreen.screenSizeX();
    y = myScreen.screenSizeY();
    dx = x / 2;

    myScreen.selectFont(fontMeasures);
    yLine = myScreen.characterSizeY() + 2;
    myScreen.selectFont(fontText);
    dy = myScreen.characterSizeY() * 2;  // gTextLarge

    yText = yLine + 4;
    maxLines = (y - yText) / dy;  // Number of lines
    yText += (y - yText - maxLines * dy) / 2;
}

void manageScreen()
{
    countFlush %= FAST_BEFORE_GLOBAL;
    if (countFlush == 0)
    {
        myScreen.regenerate();
        Serial.println("countFlush = 0 ! regenerate");
    }

    myScreen.clear();
    myScreen.selectFont(fontMeasures);
    myScreen.gText(dx * 0, dy * 0, formatString("%+6.1f %s", vTemperature, utf2iso("°C")));
    myScreen.gText(dx * 1, dy * 0, formatString("%6.1f %s", vHumidity, utf2iso(("%"))));

    myScreen.gText(x - myScreen.characterSizeX(), dy * 0, (ArduinoCloud.connected() ? "*" : "."));

    myScreen.line(0, yLine, x, yLine, myColours.black);

    myScreen.selectFont(fontText);
    for (uint8_t i = 0; i < indexLines; i += 1)
    {
        if (lines[i].charAt(0) != 0x1b)
        {
            myScreen.gTextLarge(0, yText + dy * i, utf2iso(lines[i]));
        }

        Serial.print(formatString("lines[%i].length() = %i", i, lines[i].length()));
        Serial.print("  ");
        for (uint8_t k = 0; k < vText.length(); k += 1)
        {
            Serial.print(formatString("%02x ", vText[k]));
        }
        Serial.print("  ");
        for (uint8_t k = 0; k < vText.length(); k += 1)
        {
            Serial.print(formatString("'%c' ", vText[k]));
        }
        Serial.println();
    }

    countFlush += 1;
    myScreen.flush();
    Serial.print(formatString("countFlush = %i", countFlush));
    mySerial.println();
}
//
// --- End of PDLS
//

//
// --- HDC2080
//
#include "Wire.h"

#define HDC_I2C 0x40

uint8_t bufferWrite[8] = { 0 };
uint8_t bufferRead[8] = { 0 };

static uint32_t chrono32 = 0;

float vTemperatureOld = 0.0;
float vHumidityOld = 0.0;

void configureSensor()
{
    hV_HAL_Wire_begin();

    bufferWrite[0] = 0x0e;  // HDC20X0_CONFIGURATION
    bufferWrite[1] = 0x00;  // HDC20X0_DEFAULT_SETTINGS
    hV_HAL_Wire_transfer(HDC_I2C, bufferWrite, 2, bufferRead, 0);

    bufferWrite[0] = 0x0f;  // HDC20X0_MEASURE_CONFIGURATION
    bufferWrite[1] = 0xfe;  // HDC20X0_MEASURE_SETTINGS
    hV_HAL_Wire_transfer(HDC_I2C, bufferWrite, 2, bufferRead, 0);
}

void manageSensor()
{
    Serial.println();

    // Command
    bufferWrite[0] = 0x0f;  // HDC20X0_MEASURE_CONFIGURATION
    bufferWrite[1] = 0xff;  // HDC20X0_DEFAULT_SETTINGS
    hV_HAL_Wire_transfer(HDC_I2C, bufferWrite, 2, bufferRead, 0);
    delay(50);

    // Temperature
    bufferWrite[0] = 0x00;  // HDC20X0_TEMPERATURE_LOW
    hV_HAL_Wire_transfer(HDC_I2C, bufferWrite, 1, bufferRead, 2);
    vTemperature = ((bufferRead[0] + bufferRead[1] * 256.0) * 165.0 / 65536.0) - (40.5 + 0.08 * (3.3 - 1.8));  // +273.15; // from °C to °K

    // Humidity
    bufferWrite[0] = 0x02;  // HDC20X0_HUMIDITY_LOW
    hV_HAL_Wire_transfer(HDC_I2C, bufferWrite, 1, bufferRead, 2);
    vHumidity = (bufferRead[0] + bufferRead[1] * 256.0) / 65536.0 * 100.0;

    // Rounding
    vTemperature = ((int32_t)(vTemperature * 10)) / 10.0;
    vHumidity = ((int32_t)(vHumidity * 10)) / 10.0;

    Serial.print(formatString("%6.1f %6.1f %% ? %i, %6.1f %6.1f oC ? %i", vHumidity, vHumidityOld, (vHumidity != vHumidityOld), vTemperature, vTemperatureOld, (vTemperature != vTemperatureOld)));
    Serial.println();

    if ((vHumidity != vHumidityOld) or (vTemperature != vTemperatureOld))
    {
        vHumidityOld = vHumidity;
        vTemperatureOld = vTemperature;
        flagDisplay = true;
    }
}
//
// --- End of HDC2080
//

//
// --- RGB
//
// Adafruit_NeoPixel crashes if Pin Numbering > By GPIO number (Legacy) is not selected
#include "Adafruit_NeoPixel.h"

// Which pin on the Arduino is connected to the NeoPixels?
#define PIN 7  // On Trinket or Gemma, suggest changing this to 1

// How many NeoPixels are attached to the Arduino?
#define NUMPIXELS 1  // Popular NeoPixel ring size

// When setting up the NeoPixel library, we tell it how many pixels,
// and which pin to use to send signals. Note that for older NeoPixel
// strips you might need to change the third parameter -- see the
// strandtest example for more information on possible values.
Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);

void configureRGB()
{
    pixels.setPin(myBoard.ledData);
    pixels.begin();  // INITIALIZE NeoPixel strip object (REQUIRED)
    pixels.clear();  // Set all pixel colors to 'off'
    pixels.show();   // Send the updated pixel colors to the hardware.
}

void manageRGB()
{
    bool switchRGB = vColour.getSwitch();
    Color coloursRGB = vColour.getValue();
    uint8_t r, g, b;
    coloursRGB.getRGB(r, g, b);

    mySerial.println(formatString("Switch %i, rgb %3i %3i %3i", switchRGB, r, g, b));

    if (switchRGB == false)
    {
        pixels.clear();  // Set all pixel colors to 'off'
    }
    else
    {
        r = map(r, 0, 255, 0, 64);
        g = map(g, 0, 255, 0, 64);
        b = map(b, 0, 255, 0, 64);
        mySerial.println(formatString("Normalised rgb %3i %3i %3i", r, g, b));

        pixels.setPixelColor(0, pixels.Color(r, g, b));
    }

    pixels.show();  // Send the updated pixel colors to the hardware.
}
//
// --- End of RGB
//

void setup()
{
    hV_HAL_begin();

    // Initialize serial and wait for port to open:
    Serial.begin(115200);
    // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
    delay(1500);

    configureIoT();
    configureScreen();
    configureSensor();
    configureRGB();
    configureText();

    flagStop = false;
    pinMode(myBoard.button, INPUT_PULLUP);
}

void loop()
{
    ArduinoCloud.update();
    // Your code here

    if (digitalRead(myBoard.button) == LOW)
    {
        flagStop = true;
    }

    if (flagStop == true)
    {
        pixels.clear();  // Set all pixel colors to 'off'
        pixels.show();   // Send the updated pixel colors to the hardware.

        myScreen.regenerate();

        while (0x01)
        {
            delay(1000);
        }
    }

    //
    // --- HDC2080
    //
    if (millis() > chrono32)
    {
        manageSensor();
        chrono32 = millis() + DELAY_MS;
    }
    //
    // --- End of HDC2080
    //

    //
    // --- Text
    //
    if (flagText == true)
    {
        manageText();

        flagDisplay = true;
        flagText = false;
    }
    //
    // --- End of Text
    //

    //
    // --- PDLS
    //
    if (flagDisplay == true)
    {
        manageScreen();
        flagDisplay = false;
    }
    //
    // --- End of PDLS
    //

    //
    // --- RGB
    //
    if (flagRGB == true)
    {
        manageRGB();

        flagRGB = false;
    }
    //
    // --- End of RGB
    //
}


//
// --- IoT
//
/*
  Since VText is READ_WRITE variable, onVTextChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVTextChange()
{
    // Add your code here to act upon VText change
    flagText = true;
}

/*
  Since VColour is READ_WRITE variable, onVColourChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVColourChange()
{
    // Add your code here to act upon VColour change
    flagRGB = true;
}

/*
  Since VStop is READ_WRITE variable, onVStopChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVStopChange()
{
    // Add your code here to act upon VStop change
    flagStop = true;
}
//
// --- End of IoT
//
